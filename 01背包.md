# 二维数组01背包
有N件物品和⼀个最多能被重量为W 的背包。第i件物品的重量是weight[i]，得到的价值是
value[i] 。每件物品只能⽤⼀次，求解将哪些物品装⼊背包⾥物品价值总和最⼤
 - dp[i][j]表示从下标0-i的物品中任意取出放入容量为j的背包中
 ![image](https://user-images.githubusercontent.com/88364565/198483251-331b86a6-9bd1-4130-8386-14d0d709f8c9.png)

 - 递推公式：
 1.由dp[i - 1][j]推出，即背包容量为j，⾥⾯不放物品i的最⼤价值，此时dp[i][j]就是dp[i - 1][j]
 2.由dp[i - 1][j - weight[i]]推出，dp[i - 1][j - weight[i]] 为背包容量为j - weight[i]的时候不放物品i的最⼤价值，那么dp[i - 1][j - weight[i]] + value[i] （物品i的价值），
就是背包放物品i得到的最⼤价值
所以递推公式为：dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])
 - 初始化：
 1.i为0： 
  - 物品编号为0，当weight[0] > j , 说明背包容量小于物品重量 , dp[0][j] = 0
  - 物品编号为0，当weight[0] < j , 说明背包容量大于物品重量 , do[0][j] = value[0]
```
for (int j = 0 ; j < weight[0]; j++) { // 当然这⼀步，如果把dp数组预先初始化为0了，这⼀步就可以省略
  dp[0][j] = 0;
}
// 正序遍历
for (int j = weight[0]; j <= bagWeight; j++) {
  dp[0][j] = value[0];
}
```



