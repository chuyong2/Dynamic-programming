# 二维数组01背包
有N件物品和⼀个最多能被重量为W 的背包。第i件物品的重量是weight[i]，得到的价值是
value[i] 。每件物品只能⽤⼀次，求解将哪些物品装⼊背包⾥物品价值总和最⼤
 - dp[i][j]表示从下标0-i的物品中任意取出放入容量为j的背包中
 ![image](https://user-images.githubusercontent.com/88364565/198483251-331b86a6-9bd1-4130-8386-14d0d709f8c9.png)

 - 递推公式：
 1.由dp[i - 1][j]推出，即背包容量为j，⾥⾯不放物品i的最⼤价值，此时dp[i][j]就是dp[i - 1][j]
 2.由dp[i - 1][j - weight[i]]推出，dp[i - 1][j - weight[i]] 为背包容量为j - weight[i]的时候不放物品i的最⼤价值，那么dp[i - 1][j - weight[i]] + value[i] （物品i的价值），
就是背包放物品i得到的最⼤价值
所以递推公式为：dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])
 - 初始化：
 
 1.i为0： 
  - 物品编号为0，当weight[0] > j , 说明背包容量小于物品重量 , dp[0][j] = 0
  - 物品编号为0，当weight[0] < j , 说明背包容量大于物品重量 , do[0][j] = value[0]
 2.j为0：背包容量为空，dp[i][0] = 0
```
for (int j = 0 ; j < weight[0]; j++) { // 当然这⼀步，如果把dp数组预先初始化为0了，这⼀步就可以省略
  dp[0][j] = 0;
}
// 正序遍历
for (int j = weight[0]; j <= bagWeight; j++) {
  dp[0][j] = value[0];
}
```
其实从递归公式： dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); 可以看出dp[i][j] 是又左上⽅数值推导出来了，
那么 其他下标初始为什么数值都可以，因为都会被覆盖,但只不过⼀开始就统⼀把dp数组统⼀初始为0，更⽅便⼀些。
```
int[][] dp = new int[weight.length + 1][bagWeight + 1];
for (int j = weight[0]; j <= bagWeight; j++) {
 dp[0][j] = value[0];
}
```
 - 遍历顺序：先便利物品，在遍历背包重量
```
for(int i = 1;i < weight.length ;i++){
 for(int j = 0 , j <= bagWeight ; j++){
  if (j < weight[i]) dp[i][j] = dp[i - 1][j]; // 这个是为了展现dp数组⾥元素的变化
  else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
 }
}
```





















